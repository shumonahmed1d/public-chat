// ---------------- status & toast helpers ----------------
const liveDot = document.querySelector('.live-dot'); // element present in header
function setLiveStatusOk(text = 'Live — receiving messages'){
  if(liveDot){
    liveDot.classList.remove('live-dot--error');
  }
  liveText.textContent = text;
  statusBar.textContent = text;
  statusBar.style.color = ''; // default
}

function setLiveStatusError(errMsg = 'Error connecting'){
  if(liveDot){
    liveDot.classList.add('live-dot--error');
  }
  const short = (typeof errMsg === 'string' && errMsg.length > 120) ? errMsg.slice(0,120) + '…' : errMsg;
  liveText.textContent = 'Error — ' + short;
  statusBar.textContent = 'Error: ' + short;
  statusBar.style.color = '#ff8080';
  console.error('CHAT ERROR:', errMsg);
}

// upgraded toast to show preview and label
function showCopiedToast(text){
  // make preview (max 60 chars)
  const preview = (text||'').trim().replace(/\s+/g,' ');
  const short = preview.length > 60 ? preview.slice(0,60) + '…' : preview;
  toast.innerHTML = `<span class="preview">${escapeHTML(short)}</span><span class="label">Copied to clipboard</span>`;
  toast.classList.add('show');
  clearTimeout(window._toastTimer);
  window._toastTimer = setTimeout(()=> toast.classList.remove('show'), 1800);
}

// keep old generic toast too
function showToastSimple(txt){
  toast.textContent = txt;
  toast.classList.add('show');
  clearTimeout(window._toastTimer);
  window._toastTimer = setTimeout(()=> toast.classList.remove('show'), 1400);
}

// ---------------- renderMessage: use showCopiedToast instead of showToast('Copied') ----------------
function renderMessage(data){
  try {
    const wrap = document.createElement('div');
    wrap.className = 'message ' + ((data.clientId && data.clientId === CLIENT_ID) ? 'message-out' : 'message-in');
    const bubble = document.createElement('div');
    bubble.className = 'msg-bubble';
    if(data.user){
      const un = document.createElement('span');
      un.className = 'msg-username';
      un.textContent = data.user;
      bubble.appendChild(un);
    }
    const p = document.createElement('p');
    p.innerHTML = escapeHTML(data.text || '');
    bubble.appendChild(p);
    const t = document.createElement('span');
    t.className = 'msg-time';
    t.textContent = data.time ? new Date(data.time).toLocaleString() : '';
    bubble.appendChild(t);

    // click to copy -> show preview toast
    bubble.addEventListener('click', async ()=> {
      try {
        await navigator.clipboard.writeText(data.text || '');
        showCopiedToast(data.text || '');
      } catch(e){
        showToastSimple('Copy failed');
        console.error('Copy failed', e);
      }
    });

    wrap.appendChild(bubble);
    messagesEl.appendChild(wrap);
    messagesEl.scrollTop = messagesEl.scrollHeight;
  } catch(err){
    console.error('renderMessage error', err);
  }
}

// ---------------- initChat: attach error callback for listener ----------------
function initChat(){
  if(!messagesRef){
    setLiveStatusError('Database not available');
    return;
  }

  try {
    // add error callback as 3rd arg
    onChildAdded(query(messagesRef, limitToLast(200)), snap => {
      const val = snap.val();
      if(!val) return;
      renderMessage(val);
    }, (err) => {
      // database listener error
      setLiveStatusError(err && err.message ? err.message : 'Realtime DB error');
    });

    setLiveStatusOk('Live — receiving messages');
    chatInputArea.style.visibility = 'visible';
  } catch (e){
    setLiveStatusError(e && e.message ? e.message : 'Listener attach failed');
  }

  // send handlers (unchanged)
  sendBtn.addEventListener('click', sendMessage);
  textInput.addEventListener('keydown', (e)=> { if(e.key === 'Enter'){ e.preventDefault(); sendMessage(); } });

  // keyboard / resize behavior for mobile
  window.addEventListener('resize', ()=>{ setTimeout(()=> { messagesEl.scrollTop = messagesEl.scrollHeight; window.scrollTo({ top: document.body.scrollHeight, behavior:'smooth' }); }, 120); });
  setTimeout(()=> { messagesEl.scrollTop = messagesEl.scrollHeight; }, 400);
}

// ------------- push errors -> set status to error --------------
async function sendMessage(){
  const txt = textInput.value.trim();
  if(!txt) return;
  if(!messagesRef){ showToastSimple('Not connected'); return; }
  try {
    await push(messagesRef, { text: txt, time: Date.now(), clientId: CLIENT_ID });
    textInput.value = '';
    textInput.focus();
    // after successful push, ensure status OK (in case it had transient error)
    setLiveStatusOk('Live — receiving messages');
  } catch (e){
    setLiveStatusError(e && e.message ? e.message : 'Send failed');
    showToastSimple('Send failed');
  }
}

// ------------- network events also update status --------------
window.addEventListener('offline', ()=> { setLiveStatusError('Offline — check network'); });
window.addEventListener('online', ()=> { setLiveStatusOk('Live — back online'); setTimeout(()=> setLiveStatusOk('Live — receiving messages'), 1200); });
